# C++ 知识点总结

## class Student s 与 Student s；
在创建对象时，class 关键字可要可不要，但是出于习惯我们通常会省略掉 class 关键字，例如：
> class Student LiLei;  //正确
> Student LiLei;  //同样正确

## Student* pstu = new Student;
使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。

## 不重要 用不到 类外定义inline函数
这种在类体外定义 inline 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出

## 成员访问修饰符
1. 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。  
2. 默认修饰符为private
3. protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用

## 继承关系修饰符
1. public继承方式
基类中所有 public 成员在派生类中为 public 属性；
基类中所有 protected 成员在派生类中为 protected 属性；
基类中所有 private 成员在派生类中不能使用。

2. protected继承方式
基类中的所有 public 成员在派生类中为 protected 属性；
基类中的所有 protected 成员在派生类中为 protected 属性；
基类中的所有 private 成员在派生类中不能使用。

3. private继承方式
基类中的所有 public 成员在派生类中均为 private 属性；
基类中的所有 protected 成员在派生类中均为 private 属性；
基类中的所有 private 成员在派生类中不能使用。

## 构造函数
1. 构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。***如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；***反过来说，创建对象时只有一个构造函数会被调用。
> 如果编写了有参数的构造函数，新建对象时就不能使用student s或new student；的写法了
2. 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。
3. 最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。

## 初始话列表
1. 使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。
2. 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。
> obj 在栈上分配内存，成员变量的初始值是不确定的。
3. 初始化 const 成员变量的唯一方法就是使用初始化列表。

## new delete
用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。

## this 指针
1. this 是一个指针，要用->来访问成员变量或成员函数。
2. 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用

## static成员变量
1. static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了 m_total，也会影响到其他对象。
2. static 成员变量必须在类声明的外部初始化
具体形式为：
type class::name = value;

> type 是变量的类型，class 是类名，name 是变量名，value 是初始值。  
将上面的 m_total 初始化：
int Student::m_total = 0;
3. static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。
4. static 成员变量既可以通过对象来访问，也可以通过类来访问
> //通过类类访问 static 成员变量  
Student::m_total = 10;  
//通过对象来访问 static 成员变量  
Student stu("小明", 15, 92.5f);  
stu.m_total = 20;  
//通过对象指针来访问 static 成员变量  
Student *pstu = new Student("李华", 16, 96);  
pstu -> m_total = 20;  
这三种方式是等效的。

## static成员函数
普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。
> 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。


## 常成员函数
常成员函数不能修改成员变量的值  
需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字。
> char *getname() const和char *getname()是两个不同的函数原型，如果只在一个地方加 const 会导致声明和定义处的函数原型冲突。

## 常对象
常对象只能调用类的const成员（包括cosnt成员和const成员函数）

## 友元
1. 借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问 ***当前类的 private 成员***（要是public成员就没这个必要了）。
2. 注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。下面的写法是错误的：
> void show(){  
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是   "<<m_score<<endl;  
}  
成员函数在调用时会隐式地增加 this 指针，指向调用它的对象，从而使用该对象的成员；而 show() 是非成员函数，没有 this 指针，编译器不知道使用哪个对象的成员，要想明确这一点，就必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象。
3. 友元类：友元类中的所有成员函数都是另外一个类的友元函数。
> 都不重要  
友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。  
友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。

## class与struct的区别
> 不重要  
- 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。  
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承（《C++继承与派生》一章会讲解继承）。  
- class 可以使用模板，而 struct 不能（《模板、字符串和异常》一章会讲解模板）。

## 引用
1. 引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。
2. 在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有 ***在函数内部影响函数外部数据的效果***。

## c++对象的内存模型
1. 类是常见对象的模板，不占用内存空间，不存在于编译后的可执行文件中
2. 编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码在代码区。

## 函数模板
>template<typename T> void Swap(T &a, T &b){  
    T temp = a;  
    a = b;  
    b = temp;  
}  
早期用class，后来用typename

## 异常处理
1. 不明确地抛出异常就检测不到异常
2. 运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++ 异常（Exception）机制就是为解决运行时错误而引入的。
3. 会抛出异常的函数
> string.at() 
4. 