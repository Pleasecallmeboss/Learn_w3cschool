# c++11新特性

## auto
1. 使用 auto 的时候必须对变量进行初始化
> 注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。
2. 应用
- 定义复杂的迭代器  
> vector< vector<int> >::iterator i = v.begin();  
auto i = v.begin();  //使用 auto 代替具体的类型
- 用于泛型编程（函数模板）

## decltype(exp) 和auto一样自动推导变量类型
1. 用法
> auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：  
auto varname = value;  
decltype(exp) varname = value;  
其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。
2. auto 要求变量必须初始化，而 decltype 不要求。  
> decltype 可以写成下面的形式：  
decltype(exp) varname;
3. decltype 推导规则  
- 如果 exp 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。  
- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。  
- 如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&.  

***一般用在函数模板里***
## tuple元组
tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。

## 列表初始化
1. 可以用于任何类型对象的初始化  
2. 在初始化时，{}前面的等于号是否书写对初始化行为没有影响。
> Foo a4 { 123 };   //对象  
> int a5 = { 3 };     //普通类型  
> int a6 { 3 };  
> int i_arr[3] { 1, 2, 3 };  //普通数组
> struct A  
> {  
>     int x;  
>     struct B  
>     {  
>         int i;  
>         int j;  
>     } b;  
> } a { 1, { 2, 3 } };  //POD类型 POD 类型即 plain old data 类型，简单来说，是可以直接使用  memcpy 复制的对象。  
> int* a = new int { 123 };  
> double b = double { 12.12 };  
> int* arr = new int[3] { 1, 2, 3 };  

## 匿名函数
1. 语法格式
[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型
{
   函数体;
};
- [外部变量方位方式说明符]
[ ] ***方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略***。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。
> 所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。

- (参数)
和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；

- mutable
此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。

> 注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；

- noexcept/throw()
可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

> 值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。

- -> 返回值类型
指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略-> 返回值类型。

- 函数体
和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。***该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。***

> ***需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。***

## 基于范围的for循环
1. 可以看到，同 C++ 98/03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。
2. 基于范围的 for 循环不支持遍历函数返回的以指针形式表示的数组
> 原因很简单，此格式的 for 循环只能遍历有明确范围的一组数据，上面程序中 retStr() 函数返回的是指针变量，遍历范围并未明确指明，所以编译失败。  
3. (暂时还不涉及)在使用基于范围的 for 循环遍历容器时，应避免在循环体中修改容器存储元素的个数
> 基于范围的 for 循环完成对容器的遍历，其底层也是借助容器的迭代器实现的.因为在 for 循环遍历 arr 容器的同时向该容器尾部添加了新的元素（对 arr 容器进行了扩增），致使遍历容器所使用的迭代器失效，整个遍历过程出现错误。

## nullptr
> C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：  
int *p = 0;  
int *p = NULL; //推荐使用  
NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。
1. nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针
> nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用）  
nullptr 可以被隐式转换成任意的指针类型。举个例子：  
int * a1 = nullptr;  
char * a2 = nullptr;  
double * a3 = nullptr;  

## 智能指针 shared_ptr
1. 智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。 
2. 多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。
